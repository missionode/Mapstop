<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Map Route Builder — Predicted 4th Point</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<style>
  html,body,#map{height:100%;margin:0}
  .controls{position:absolute;top:12px;left:12px;z-index:1000;display:flex;gap:8px;flex-wrap:wrap}
  .btn{border:1px solid #cbd5e1;background:#fff;padding:8px 12px;border-radius:8px;font:600 14px system-ui;box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer}
  .btn[disabled]{opacity:.45;cursor:not-allowed}
  #panel{position:absolute;top:56px;left:12px;z-index:1000;width:min(92vw,380px);background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.12);display:none}
  #searchBox{padding:10px;border-bottom:1px solid #e2e8f0}
  #query{width:100%;box-sizing:border-box;padding:10px 12px;border:1px solid #cbd5e1;border-radius:8px;font-size:14px}
  #results{max-height:220px;overflow:auto}
  .result{padding:8px 10px;cursor:pointer}
  .result:hover{background:#f1f5f9}
  .empty{color:#64748b;font-size:13px;padding:8px}
  #waypoints{max-height:260px;overflow:auto;border-top:1px solid #e2e8f0}
  .wp{display:flex;align-items:center;gap:8px;padding:8px 10px;border-bottom:1px solid #f1f5f9}
  .handle{cursor:grab;font:600 14px/1 monospace;color:#64748b}
  .label{flex:1 1 auto;font-size:13px}
  .del{border:none;background:#fee2e2;color:#991b1b;font-weight:700;border-radius:6px;padding:6px 8px;cursor:pointer}
</style>
</head>
<body>
<div id="map"></div>

<div class="controls">
  <button id="addBtn" class="btn">Add Place</button>
  <button id="clearBtn" class="btn">Clear</button>
  <label class="btn" style="display:flex;gap:6px;align-items:center;">
    <input type="checkbox" id="snapChk"/> Snap to road
  </label>
  <button id="exportBtn" class="btn">Export GeoJSON</button>
  <button id="usePredBtn" class="btn" disabled>Use prediction ➕</button>
</div>

<div id="panel">
  <div id="searchBox">
    <input id="query" type="text" placeholder="Search a place (min 3 chars)..." autocomplete="off"/>
  </div>
  <div id="results"></div>
  <div style="padding:8px 10px;font-weight:700">Waypoints</div>
  <div id="waypoints"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script>
/* --- Map --- */
const map = L.map('map').setView([20.5937,78.9629],5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'&copy; OpenStreetMap'}).addTo(map);

const addBtn = document.getElementById('addBtn');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');
const snapChk = document.getElementById('snapChk');
const usePredBtn = document.getElementById('usePredBtn');
const panel = document.getElementById('panel');
const query = document.getElementById('query');
const results = document.getElementById('results');
const wpList = document.getElementById('waypoints');

const points = []; // [{lat,lon,label,marker}]
let straightLine = L.polyline([], { weight: 4 }).addTo(map);
let snappedLine  = L.polyline([], { weight: 4, dashArray: '6 6' }).addTo(map);

/* Predicted next point visuals (D) */
const predLine = L.polyline([], { weight: 2, dashArray:'2 8', color:'#6b7280' }).addTo(map); // dotted C→D
const predMarker = L.circleMarker([0,0], {
  radius: 7, weight: 2, color:'#6b7280', fillColor:'#9ca3af',
  opacity: 0, fillOpacity: 0   // start hidden
}).addTo(map);

let lastPrediction = null; // {lat, lon}

function openPanel(){ panel.style.display='block'; results.innerHTML=''; query.value=''; query.focus(); }
function closePanel(){ panel.style.display='none'; }
addBtn.addEventListener('click', ()=> panel.style.display==='block' ? closePanel() : openPanel());

function addPlace([lat, lon], label){
  const marker = L.marker([lat,lon]).addTo(map).bindPopup(`<b>${label}</b><br>${lat.toFixed(5)}, ${lon.toFixed(5)}`);
  points.push({lat,lon,label,marker});
  refresh();
}
function removeIndex(i){
  const p = points[i]; if(!p) return;
  map.removeLayer(p.marker);
  points.splice(i,1);
  refresh();
}
function clearAll(){
  points.forEach(p=>map.removeLayer(p.marker));
  points.length = 0;
  refresh();
}
clearBtn.addEventListener('click', clearAll);

function refresh(){
  straightLine.setLatLngs(points.map(p=>[p.lat,p.lon]));
  if(points.length===1) map.setView([points[0].lat,points[0].lon], 12);
  if(points.length>=2) map.fitBounds(straightLine.getBounds(), { padding:[40,40] });
  buildList();
  scheduleRouteUpdate();
  updatePredictedPoint();
}

function buildList(){
  wpList.innerHTML = '';
  points.forEach((p,idx)=>{
    const row = document.createElement('div');
    row.className = 'wp';
    row.draggable = true;
    row.dataset.index = idx;

    const handle = document.createElement('span');
    handle.className = 'handle';
    handle.textContent = '↕';
    row.appendChild(handle);

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = `${idx+1}. ${p.label}`;
    row.appendChild(label);

    const del = document.createElement('button');
    del.className = 'del';
    del.textContent = '×';
    del.title = 'Remove';
    del.onclick = ()=>removeIndex(idx);
    row.appendChild(del);

    row.addEventListener('dragstart', e=>{
      e.dataTransfer.setData('text/plain', idx);
      e.dataTransfer.effectAllowed = 'move';
    });
    row.addEventListener('dragover', e=>{ e.preventDefault(); e.dataTransfer.dropEffect='move'; });
    row.addEventListener('drop', e=>{
      e.preventDefault();
      const from = +e.dataTransfer.getData('text/plain');
      const to = +row.dataset.index;
      if(from===to) return;
      const [moved] = points.splice(from,1);
      points.splice(to,0,moved);
      refresh();
    });

    wpList.appendChild(row);
  });
}

/* --- Search (Nominatim) --- */
let debounceTimer=null, abortCtrl=null;
function showResults(items){
  results.innerHTML = '';
  if(!items.length){ results.innerHTML = '<div class="empty">No matches</div>'; return; }
  for(const item of items){
    const div = document.createElement('div');
    div.className = 'result';
    div.textContent = item.display_name;
    div.onclick = ()=>{
      addPlace([parseFloat(item.lat), parseFloat(item.lon)], item.display_name);
      closePanel();
    };
    results.appendChild(div);
  }
}
query.addEventListener('input', e=>{
  const q = e.target.value.trim();
  if(q.length<3){ results.innerHTML=''; if(abortCtrl) abortCtrl.abort(); return; }
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(async ()=>{
    try{
      if(abortCtrl) abortCtrl.abort();
      abortCtrl = new AbortController();
      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=8&q=${encodeURIComponent(q)}`;
      const res = await fetch(url,{signal:abortCtrl.signal, headers:{'Accept':'application/json'}});
      const data = await res.json();
      showResults(data);
    }catch(err){ if(err.name!=='AbortError') results.innerHTML='<div class="empty">Search failed</div>'; }
  },300);
});

/* --- Snap-to-road (OSRM) --- */
snapChk.addEventListener('change', ()=>scheduleRouteUpdate());
let routeTimer=null;
function scheduleRouteUpdate(){ clearTimeout(routeTimer); routeTimer=setTimeout(updateRoute, 150); }
async function updateRoute(){
  snappedLine.setLatLngs([]);
  if(!snapChk.checked || points.length<2) return;
  const coords = points.map(p=>`${p.lon},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try{
    const res = await fetch(url);
    if(!res.ok) throw new Error('routing failed');
    const data = await res.json();
    const geom = data?.routes?.[0]?.geometry;
    if(!geom) return;
    const latlngs = geom.coordinates.map(([lng,lat])=>[lat,lng]);
    snappedLine.setLatLngs(latlngs);
  }catch(e){ /* silent */ }
}

/* --- Export GeoJSON --- */
function toGeoJSON(){
  const fc = { type:"FeatureCollection", features:[] };
  for(const [i,p] of points.entries()){
    fc.features.push({ type:"Feature", properties:{order:i+1,name:p.label}, geometry:{ type:"Point", coordinates:[p.lon,p.lat] }});
  }
  if(points.length>=2){
    fc.features.push({
      type:"Feature",
      properties:{ name: snapChk.checked ? "route_snapped" : "route_straight" },
      geometry:{
        type:"LineString",
        coordinates: (snappedLine.getLatLngs().length && snapChk.checked)
          ? snappedLine.getLatLngs().map(ll=>[ll.lng,ll.lat])
          : points.map(p=>[p.lon,p.lat])
      }
    });
  }
  return fc;
}
exportBtn.addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(toGeoJSON(),null,2)], {type:'application/geo+json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'route.geojson';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(a.href);
});

/* --- Predict 4th point from last three (A,B,C) ---
   D = intersection of line(AB) and ray from C along (B→C).
   If parallel or hit behind C, hide prediction.
   Uses local equirectangular projection for 2D math.
*/
const EPS = 1e-12;
const deg2rad = d=>d*Math.PI/180;
function project(pt, lat0){ const cl=Math.cos(deg2rad(lat0)); return {x:pt.lon*cl, y:pt.lat}; }
function unproject(xy, lat0){ const cl=Math.cos(deg2rad(lat0)); return {lat:xy.y, lon:xy.x/cl}; }

function lineRayIntersection(A,B,C){
  const lat0=(A.lat+B.lat+C.lat)/3;
  const a=project(A,lat0), b=project(B,lat0), c=project(C,lat0);
  const r={x:b.x-a.x, y:b.y-a.y};   // AB direction
  const s={x:c.x-b.x, y:c.y-b.y};   // BC direction
  const p=a, q=c;
  const rxs=r.x*s.y - r.y*s.x;
  if(Math.abs(rxs)<EPS) return null;      // parallel
  const q_p={x:q.x-p.x, y:q.y-p.y};
  const u=(q_p.x*r.y - q_p.y*r.x)/rxs;   // along ray
  if(u<0) return null;                   // behind C
  const t=(q_p.x*s.y - q_p.y*s.x)/rxs;   // on AB line
  const hit={x:p.x + t*r.x, y:p.y + t*r.y};
  const D=unproject(hit,lat0);
  return D;
}

function setUsePredEnabled(enabled){
  usePredBtn.disabled = !enabled;
}
function hidePrediction(){
  lastPrediction = null;
  predMarker.setStyle({ opacity: 0, fillOpacity: 0 });
  predLine.setLatLngs([]);
  setUsePredEnabled(false);
}
function showPrediction(C, D){
  lastPrediction = D;
  predMarker
    .setLatLng([D.lat, D.lon])
    .setStyle({ opacity: 0.8, fillOpacity: 0.35 })
    .bindPopup('<b>Predicted next point</b>');
  predLine.setLatLngs([[C.lat,C.lon],[D.lat,D.lon]]);
  setUsePredEnabled(true);
}

function updatePredictedPoint(){
  if(points.length<3){ hidePrediction(); return; }
  const n=points.length;
  const A=points[n-3], B=points[n-2], C=points[n-1];
  const D=lineRayIntersection(A,B,C);
  if(!D){ hidePrediction(); return; }
  showPrediction(C, D);
}

/* --- Use prediction button --- */
usePredBtn.addEventListener('click', ()=>{
  if(!lastPrediction) return;
  const {lat, lon} = lastPrediction;
  addPlace([lat, lon], 'Predicted point');
  // After adding, a new prediction will be computed automatically in refresh()
});
</script>
</body>
</html>
